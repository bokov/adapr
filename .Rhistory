get.project.info.si(pull_source_info("test_adapr"))
get.project.info.si(pull_source_info("test_adapr"))$all.files
project.id <- "test_adapr"
get.project.info.si(pull_source_info(project.id))$all.files
rework.project.path
swap.project.paths
si <- pull_source_info(project.id)
gsub(si$project.path,"",fixed=TRUE,get.project.info.si(si)$all.files$fullname)
file.path("asfd","")
gsub(file.path(si$project.path,""),"",fixed=TRUE,get.project.info.si(si)$all.files$fullname)
si <- pull_source_info(project.id)
files <- get.project.info.si(si)$all.files
paths <- gsub(file.path(si$project.path,""),"",fixed=TRUE,files$fullname)
descriptions <- files$description
paths
descriptions
subset(data.frame(path=paths,description=descriptions),grepl("^Results",path))
shiny::runApp('~/Documents/Projects/adapr/inst/shinyApp')
shiny::runApp('~/Documents/Projects/adapr/inst/shinyApp')
shiny::runApp('~/Documents/Projects/adapr/inst/shinyApp')
shiny::runApp('~/Documents/Projects/adapr/inst/shinyApp')
shiny::runApp('~/Documents/Projects/adapr/inst/shinyApp')
get_filelist("test_adapr")
get_filelist("test_adapr")$path
shiny::runApp('~/Documents/Projects/adapr/inst/shinyApp')
shiny::runApp('~/Documents/Projects/adapr/inst/shinyApp')
get_filelist <- function(project.id){
si <- pull_source_info(project.id)
files <- get.project.info.si(si)$all.files
paths <- gsub(file.path(si$project.path,""),"",fixed=TRUE,files$fullname)
descriptions <- files$description
results <- subset(data.frame(path=paths,description=descriptions,stringsAsFactors=FALSE),grepl("^Results",path))
results$path <-  gsub(file.path("Results",""),"",fixed=TRUE,results$path)
return(results)
}
get_filelist("test_adapr")
shiny::runApp('~/Documents/Projects/adapr/inst/shinyApp')
shiny::runApp('~/Documents/Projects/adapr/inst/shinyApp')
shiny::runApp('~/Documents/Projects/adapr/inst/shinyApp')
shiny::runApp('~/Documents/Projects/adapr/inst/shinyApp')
get.project.swap.directory("test_adapr")
get_orchard()
get.project.swap.directory
shiny::runApp('~/Documents/Projects/adapr/inst/shinyApp')
q()
load_all()
q()
library(devtools)
load_all()
library(adapr)
library(adapr)
load_all()
library(adapr)
shinyTree()
load_all()
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
library(plyr)
library(dplyr)
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
load_all()
library(adapr)
?rbind.fill
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
load_all()
library(adapr)
shiny::runApp('inst/shinyApp')
git.configure.test()
temp <- git.configure.test()
temp
gitAuthor <- names(temp)
gitAuthor
temp <- git.configure.test()
temp
git.configure.test
system2(git_binary_path, paste("config --global user.name"))
system2(git_binary_path, paste("config --global user.name"))
gitAuthor <- captureOutput(temp)
gitAuthor <- capture.output(temp)
gitAuthor <- capture.output(temp)
gitAuthor
gitAuthor <- capture.output(git.configure.test())
gitAuthor
system2(git_binary_path, paste("config --global user.name"),stdout=TRUE)
system2(git_path(NULL), paste("config --global user.name"),stdout=TRUE)
system2(git_path(NULL), paste("config --global email"),stdout=TRUE)
system2(git_path(NULL), paste("config --global mail"),stdout=TRUE)
system2(git_path(NULL), paste("config --global email"),stdout=TRUE)
system2(git_path(NULL), paste("config --global user.email"),stdout=TRUE)
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
class(gitAuthor)
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
dir.exists
dir.exists(project.path
)
shinyTree()
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
Check.file.hash
source_info
rm(list=ls())
set.seed( 2011 )
library(adapr)
require(knitr)
source.file <-"read_data.R"
project.id <- "test_adapr"
source_info <- create_source_file_dir(source.description="reads data")
# Program body here
print("Check")
#project_report_send_rmd(target.directory=get.project.publish.path(project.id),source_info,send.data=FALSE, graph.width = 960, graph.height = 500)
ostype <- .Platform$OS.type
topdirs <- list.files(path.expand.2("~"),full.names=TRUE)
project.path <- file.path(grep("Documents$",topdirs,value=1)[1],"Projects")
publish.path <- file.path(project.path,"Publish")
publish.path <- gsub("\\\\","/",publish.path)
project.path <- gsub("\\\\","/",project.path)
#print(publish.path)
#print(project.path)
dir.create(project.path,recursive=TRUE)
dir.create(publish.path,recursive=TRUE)
project.path.start <- ifelse(dir.exists(project.path),project.path,"")
publish.path.start <- ifelse(dir.exists(publish.path),publish.path,"")
# End Program Body
dependency.out <- finalize_dependency()
dependency.dir <- source_info$dependency.dir
trees <- Harvest.trees(dependency.dir)
trees <- subset(trees,!is.na(dependency))
trees
source.df <- subset(trees,!duplicated(source.hash))
source.hash.count <- ddply(source.df,"source.file",function(x){
all.hash <- unique(x$source.hash)
n.unique.hash <- length(unique(all.hash))
out.counts <- data.frame(path=x$source.file.path[1],file=x$source.file[1],n.unique.hash=n.unique.hash,file.hash=all.hash,stringsAsFactors=FALSE)
return(out.counts)
})
source.hash.count
target.hash.count <- ddply(trees,c("target.path","target.file"),function(x){
all.hash <- unique(x$target.hash)
n.unique.hash <- length(unique(all.hash))
out.counts <- data.frame(path=x$target.path[1],file=x$target.file[1],n.unique.hash=n.unique.hash,file.hash=all.hash,stringsAsFactors=FALSE)
return(out.counts)
})
target.hash.count
all.hash.counts <- rbind.fill(source.hash.count,target.hash.count)
multiple.hash <- subset(all.hash.counts,n.unique.hash!=1,select=c("path","file","file.hash","n.unique.hash"))
multiple.hash
hash.compute <- ddply(all.hash.counts,c("path","file","file.hash","n.unique.hash"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$path[1],x$file[1]),serialize=FALSE)
})
out.counts <- data.frame(current.hash=current.hash,stringsAsFactors=FALSE)
return(out.counts)
})
hash.compute
stale.hash <- subset(hash.compute,current.hash!=file.hash)
hash.fail <- as.logical(nrow(multiple.hash)+nrow(stale.hash))
stale.hash
all.hash.counts
trees
trees
trees
source.df <- subset(trees,!duplicated(source.hash))
#Check source hashes are current
source.hash.count <- ddply(source.df,c("source.file","path","file"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$path[1],x$file[1]),serialize=FALSE)
})
x$hash.fail <- current.hash != x$target.hash
return(out.counts)
})
source.df <- subset(trees,!duplicated(source.hash))
#Check source hashes are current
source.hash.count <- ddply(source.df,c("source.file","path","file"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$path[1],x$file[1]),serialize=FALSE)
})
x$hash.fail <- current.hash != x$target.hash
return(out.counts)
})
source.df
source.hash.count <- ddply(source.df,c("source.file","path","file"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$path[1],x$file[1]),serialize=FALSE)
})
hash.fail <- current.hash != x$target.hash
return(data.frame(hash.fail))
})
source.df
source.df <- subset(trees,!duplicated(source.hash))
#Check source hashes are current
source.hash.count <- ddply(source.df,c("source.file","source.file.path",function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$source.filepath[1],x$source.file[1]),serialize=FALSE)
})
hash.fail <- current.hash != x$target.hash
return(data.frame(hash.fail))
})
source.hash.count <- ddply(source.df,c("source.file","source.file.path"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$source.filepath[1],x$source.file[1]),serialize=FALSE)
})
hash.fail <- current.hash != x$target.hash
return(data.frame(hash.fail))
})
source.df
source.hash.count <- ddply(source.df,c("source.file","source.file.path"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$source.filepath[1],x$source.file[1]),serialize=FALSE)
})
hash.fail <- current.hash != x$source.hash
return(data.frame(hash.fail))
})
source.hash.count <- ddply(source.df,c("source.file","source.file.path"),function(x){
current.hash <- ""
try({
# current.hash <- Digest(file=file.path(x$source.filepath[1],x$source.file[1]),serialize=FALSE)
})
hash.fail <- current.hash != x$source.hash
return(data.frame(hash.fail))
})
source.hash.count <- ddply(source.df,c("source.file","source.file.path"),function(x){
current.hash <- ""
try({
# current.hash <- Digest(file=file.path(x$source.file.path[1],x$source.file[1]),serialize=FALSE)
})
hash.fail <- current.hash != x$source.hash
return(data.frame(hash.fail))
})
source.hash.count
source.hash.count <- ddply(source.df,c("source.file","source.file.path"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$source.file.path[1],x$source.file[1]),serialize=FALSE)
})
hash.fail <- current.hash != x$source.hash
return(data.frame(hash.fail))
})
source.hash.count
target.hash.count <- ddply(trees,c("source.file","source.file.path","target.path","target.file"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$path[1],x$file[1]),serialize=FALSE)
})
x$hash.fail <- current.hash != x$target.hash
return(x)
})
target.hash.count <- ddply(trees,c("source.file","source.file.path","target.path","target.file"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$target.path[1],x$target.file[1]),serialize=FALSE)
})
x$hash.fail <- current.hash != x$target.hash
return(x)
})
target.hash.count
subset(target.hash.check,hash.fail)
target.hash.check <- ddply(trees,c("source.file","source.file.path","target.path","target.file"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$target.path[1],x$target.file[1]),serialize=FALSE)
})
x$hash.fail <- current.hash != x$target.hash
return(x)
})
target.hash.check
failed.sources <- subset(source.hash.check,hash.fail)
#' Checks the consistency of the dependency directory with the files within the file system
#' Reports the source scripts that need to be updated!
#' @param dependency.dir Directory with dependency information files
#' @param dependency.object data frame with dependency information
#' @details Only needs one or the other argument.
#' @return list of information about file hase mismatches
#' @export
#'
Check.file.hash.source <- function(dependency.dir=NULL,dependency.object=NULL){
if(is.null(dependency.object)){
trees <- Harvest.trees(dependency.dir)
trees <- subset(trees,!is.na(dependency))
}else{trees <- dependency.object}
source.df <- subset(trees,!duplicated(source.hash))
#Check source hashes are current
source.hash.check <- ddply(source.df,c("source.file","source.file.path"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$source.file.path[1],x$source.file[1]),serialize=FALSE)
})
hash.fail <- current.hash != x$source.hash
return(data.frame(hash.fail))
})
failed.sources <- subset(source.hash.check,hash.fail)
failed.sources$file <- failed.sources$source.file
failed.sources$path <- failed.sources$source.path
#Check target hashes are current
target.hash.check <- ddply(trees,c("source.file","source.file.path","target.path","target.file"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$target.path[1],x$target.file[1]),serialize=FALSE)
})
x$hash.fail <- current.hash != x$target.hash
return(x)
})
failed.targets <- subset(target.hash.check,hash.fail)
sources.of.failed.targets <- subset(failed.targets,select=c("source.file","source.path"))
sources.of.failed.targets$file <- sources.of.failed.targets$source.file
sources.of.failed.targets$path <- sources.of.failed.targets$source.path
all.sources.torun <- rbind(subset(sources.of.failed.targets,select=c("file","path")),subset(failed.sources,select=c("file","path")))
all.sources.torun <- unique(all.sources.torun)
failed.targets$file <- failed.targets$target.file
failed.targets$path <- failed.targets$target.path
all.failures <- rbind(subset(sources.of.failed.targets,select=c("file","path")),subset(failed.sources,select=c("file","path")))
out.list <- list(hash.fail= all.sources.torun,stale.hash=unique(all.failures))
return(out.list)
}
project.id
source_info
source_info$project.id
Check.file.hash.source(source_info$dependency.dir)
dependency.dir <- source_info$dependency.dir
if(is.null(dependency.object)){
trees <- Harvest.trees(dependency.dir)
trees <- subset(trees,!is.na(dependency))
}else{trees <- dependency.object}
source.df <- subset(trees,!duplicated(source.hash))
#Check source hashes are current
source.hash.check <- ddply(source.df,c("source.file","source.file.path"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$source.file.path[1],x$source.file[1]),serialize=FALSE)
})
hash.fail <- current.hash != x$source.hash
return(data.frame(hash.fail))
})
source.hash.check
failed.sources <- subset(source.hash.check,hash.fail)
failed.sources$file <- failed.sources$source.file
failed.sources$path <- failed.sources$source.path
#Che
failed.sources
failed.sources <- subset(source.hash.check,hash.fail)
failed.sources$file <- failed.sources$source.file
failed.sources$path <- failed.sources$source.file.path
failed.sources
target.hash.check <- ddply(trees,c("source.file","source.file.path","target.path","target.file"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$target.path[1],x$target.file[1]),serialize=FALSE)
})
x$hash.fail <- current.hash != x$target.hash
return(x)
})
failed.targets <- subset(target.hash.check,hash.fail)
sources.of.failed.targets <- subset(failed.targets,select=c("source.file","source.file.path"))
sources.of.failed.targets
sources.of.failed.targets$file <- sources.of.failed.targets$source.file
sources.of.failed.targets$path <- sources.of.failed.targets$source.path
all.sources.torun <- rbind(subset(sources.of.failed.targets,select=c("file","path")),subset(failed.sources,select=c("file","path")))
all.sources.torun <- unique(all.sources.torun)
failed.targets$file <- failed.targets$target.file
failed.targets$path <- failed.targets$target.path
all.failures <- rbind(subset(sources.of.failed.targets,select=c("file","path")),subset(failed.sources,select=c("file","path")))
sources.of.failed.targets$file <- sources.of.failed.targets$source.file
sources.of.failed.targets$path <- sources.of.failed.targets$source.file.path
all.sources.torun <- rbind(subset(sources.of.failed.targets,select=c("file","path")),subset(failed.sources,select=c("file","path")))
all.sources.torun <- unique(all.sources.torun)
failed.targets$file <- failed.targets$target.file
failed.targets$path <- failed.targets$target.path
all.failures <- rbind(subset(sources.of.failed.targets,select=c("file","path")),subset(failed.sources,select=c("file","path")))
all.failures
all.sources.torun
shinyTree()
rm(source_info)
shinyTree()
shiny::runApp('~/Documents/Projects/adapr/inst/shinyApp')
shiny::runApp('~/Documents/Projects/adapr/inst/shinyApp')
load_all()
load_all()
library(devtools)
load_all()
ls()
library(adapr)
load_all()
library(adapr)
load_all()
library(adapr)
load_all()
library(adapr)
shiny::runApp('inst/shinyApp')
load_all()
library(adapr)
load_all()
library(adapr)
load_all()
library(adapr)
topdirs <- list.files(path.expand.2("~"),full.names=TRUE)
library(adapr)
topdirs <- list.files(path.expand.2("~"),full.names=TRUE)
topdirs
shiny::runApp('inst/shinyApp')
---
shinyTree()
library(adapr)
shinyTree()
get_filelist
shiny::runApp('inst/shinyApp')
load_all()
library(adapr)
load_all()
library(adapr)
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
laod_all()
load_all()
library(adapr)
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
get_publication_file("testadapr")
get_publication_file(project.id){
# Retrieves or creates publication table from project.id
source_info <- pull_source_info(project.id)
publication.file <- file.path(source_info$project.path,project.directory.tree$support,"files_to_publish.csv")
if(file.exists(publication.file)){
publication.table <- read.csv(publication.file,as.is=TRUE)
}else{
publication.table <- data.frame(Path="",Description="")[-1,]
write.csv(publication.table,publication.file,row.names=FALSE)
}
return(publication.table)
}
get_publication_file <- function(project.id){
# Retrieves or creates publication table from project.id
source_info <- pull_source_info(project.id)
publication.file <- file.path(source_info$project.path,project.directory.tree$support,"files_to_publish.csv")
if(file.exists(publication.file)){
publication.table <- read.csv(publication.file,as.is=TRUE)
}else{
publication.table <- data.frame(Path="",Description="")[-1,]
write.csv(publication.table,publication.file,row.names=FALSE)
}
return(publication.table)
}
get_publication_file("testadapr")
get_publication_file("test_adapr")
get_publication_file("adaprHome")
get_filelist("test_adapr")
get_publication_file("testadapr")
get_publication_file("test_adapr")
get_filelist <- function(project.id){
# Get files and descriptions for project
si <- pull_source_info(project.id)
files <- get.project.info.si(si)$all.files
paths <- gsub(paste0(si$project.path,"/"),"",fixed=TRUE,files$fullname)
descriptions <- files$description
results$path <-  gsub(paste0(si$project.path,"/"),"",fixed=TRUE,results$path)
return(results)
}
get.project.info.si(pull_source_info("test_adapr"))$all.files
project.id <- "test_adapr"
si <- pull_source_info(project.id)
files <- get.project.info.si(si)$all.files
files$Path <- gsub(paste0(si$project.path,"/"),"",fixed=TRUE,files$fullname)
files$Description <- files$description
results <- subset(files,select=c("Path","Description"))
return(results)
results
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
filetosend <- "Results/read_data.R/read_data.html"
input <- list(project.id = "test_adapr")
source_info <- pull_source_info(input$project.id)
publication.table <- get_publication_table(input$project.id)
outtable <- publication.table
print("Publication table retrieved")
publication.table
possible.paths <- get_filelist(input$project.id)
if(!(filetosend %in% publication.table$Path)){
print("File not in publication path")
(!(filetosend %in% publication.table$Path)
)
file.exists(file.path(source_info$project.path,filetosend))
print(paste("Sending file",filetosend))
print(filetosend)
publication.table <- rbind(publication.table,subset(possible.paths,Path==filetosend))
print(publication.table)
write.csv(publication.table,publication.file,row.names=FALSE)
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
get.project.publish.path("test_adapr")
load_all()
library(adapr)
shiny::runApp('inst/shinyApp')
load_all()
library(adapr)
