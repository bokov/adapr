source('~/Documents/Projects/adapr/R/commit_project.R')
commit2char(commites(repo)[[1]])
commit2char(commits(repo)[[1]])
?config
config(repo)
discover_repository("~/Documents/")
discover_repository(get.project.path("adaprHome"))
config()
config()@user.name
class(config())
?git_config
names(git_config)
names(config())
config()$global$user.name
author <- git2r::config()$global$user.name
class(author)
author
git.init
library(adapr)
library(adapr)
library(adapr)
library(adapr)
Check.file.hash(pull_source_info("adaprHome")$dependency.dir)
#Check.file.hash.source()
Check.file.hash.source(pull_source_info("adaprHome")$dependency.dir)
Check.file.mtime.source(pull_source_info("adaprHome")$dependency.dir)
trees <- Harvest.trees(pull_source_info("adaprHome")$dependency.dir)
Condense.file.info(trees)
source_info <- create_source_file_dir("adaprHome","tree_controller.R")
file0 <- file.path(pull_source_info("adaprHome")$project.path,project.directory.tree$analysis,"read_data.R")
Create.file.info(dirname(file0),basename(file0),"a program that reads")
file0 <- file.path(pull_source_info("adaprHome")$project.path,project.directory.tree$analysis,"read_data.R")
Digest(file=file0)
checkAdaprHashAlgo()
source_info <- create_source_file_dir("adaprHome","tree_controller.R")
Get.file.info(source_info,file0="read_data.R")
get.fs.time()
projInfo <- get.project.info(pull_source_info("adaprHome")$dependency.dir)
plot(projInfo$graph)
source_info <- create_source_file_dir("adaprHome","tree_controller.R")
get.project.info.si(source_info)
get.project.path("adaprHome")
get.project.publish.path("adaprHome")
###########get.project.swap.directory("adaprHome")
opt <- get_adapr_options()
print(opt)
orchard <- get_orchard()
print(subset(orchard,project.id=="adaprHome"))
si <- pull_source_info("adaprHome")
file0 <- file.path(si$project.path,project.directory.tree$analysis,"read_data.R")
git.add(si$project.path,file0)
si <- pull_source_info("adaprHome")
git.commit(si$project.path,"test commit")
git.configure("jonG","gelfond@somewhere.com")
git.configure.test()
si <- pull_source_info("adaprHome")
git.history.search(si$project.path,"read_data.R")
si <- pull_source_info("adaprHome")
file0 <- file.path(si$project.path,project.directory.tree$analysis,"read_data.R")
git.info(si$project.path,file0)
#requires git commit
si <- pull_source_info("adaprHome")
file0 <- file.path(si$project.path,project.directory.tree$analysis,"read_data.R")
git_provenance("adaprHome",file0)
source_info <- create_source_file_dir("adaprHome","tree_controller.R")
Graph("test.png","histogram of normals")
hist(rnorm(1000))
dev.off()
guess.read.fcn("me.csv")
guess.read.fcn("me.xlsx")
guess.read.fcn("me.txt")
guess.write.fcn("test.png")
guess.write.fcn("test.pdf")
guess.write.fcn("test.csv")
trees <- Harvest.trees(pull_source_info("adaprHome")$dependency.dir)
Condense.file.info(trees)
si <- pull_source_info("adaprHome")
file0 <- file.path(si$project.path,project.directory.tree$analysis,"read_data.R")
source_info <- create_source_file_dir("adaprHome","tree_controller.R")
showResults()
set.project("AdaprHome")
set.project("AdaprHome",TRUE)
set.project("AdaprHome",FALSE)
init.project("Hello1")
init.project("Hello1")
set.project("Hello1")
list.proj
list.programs()
run.program("read_data.R")
run.program
run.program <- function(project.id=get.project(),source.file=get("source_info")$file$file,logRmd=FALSE){
scriptfile <- file.path(get.project.path(project.id),project.directory.tree$analysis,source.file)
# get project object
if(!logRmd){
out <- devtools::clean_source(scriptfile)
}else{
results <- file.path(get.project.path(project.id),project.directory.tree$results,source.file)
dir.create(results,showWarnings=FALSE)
program <- scan(scriptfile,what=character(),sep="\n")
program <- c("```{r}\n\n",paste("\n\n #adapr Run: \n Sys.time() \n\n"),program,"\n\n #adapr Stop: \n Sys.time() \n\n```")
dbname <- gsub("\\.","_",make.names(source.file))
tempmkdown <- file.path(results,paste0(dbname,"_adapr_results_log.Rmd"))
executor <- file.path(results,"adapr_render.R")
temphtml <- file.path(results,paste0(dbname,"_adapr_results_log.html"))
dependency.file <- file.path(get.project.path(project.id),project.directory.tree$dependency.dir,
paste0(source.file,".txt"))
write(program,tempmkdown)
olddir <- getwd()
setwd(results)
filetest <- paste0("\ntest <- file.exists(\"",temphtml,"\")\n")
renderstatement <- paste0("library(markdown)\n setwd(\"",results,"\")","\nrmarkdown::render(\"",tempmkdown,"\")",filetest,"\n if(!test){stop()}")
write(renderstatement,executor)
out <- devtools::clean_source(executor)
depout <- read.dependency(dependency.file)
outline <- depout[nrow(depout),]
outline$target.path <- file.path(project.directory.tree$results,source.file)
outline$target.file <- basename(temphtml)
outline$dependency <- "out"
outline$target.description <- "R script log in rmarkdown"
outline$target.hash <- Digest(file=temphtml)
outline$target.mod.time <- as.character(file.info(temphtml)$mtime)
depout <- rbind(depout,outline)
file.remove(c(tempmkdown,executor))
write.dependency(depout,dependency.file)
setwd(olddir)
}
return(out)
}
#' Remove an R script from a project. Removes program, dependency, and results.
#' @param project.id project id
#' @param source.file R script within that project
#' @param ask is a logical whether to ask user
#' @return value from file.remove
#' @details Cannot be undone through adapr! Will not remove markdown or other program side-effects.
#' @export
#'
#'@examples
#'\dontrun{
#' remove.program("adaprHome","read_data.R")
#'}
#'
remove.program <- function(project.id=get.project(),source.file=get("source_info")$file$file,ask=TRUE){
# get project object
if(ask){
test <- readline("Are you sure you want to remove program & results? y/n")
if(test!="y"){
return(FALSE)
}
}
program <- file.path(get.project.path(project.id),project.directory.tree$analysis,source.file)
dependencyDir <- file.path(get.project.path(project.id),project.directory.tree$dependency.dir,
paste0(source.file,".txt"))
results <- file.path(get.project.path(project.id),project.directory.tree$results,source.file)
inside.results <- list.files(results,full.names=TRUE,recursive = TRUE)
while(length(inside.results)>0){
inside.out <- file.remove(inside.results)
inside.results <- list.files(results,full.names=TRUE,recursive = TRUE,include.dirs = TRUE)
}
results.out <- file.remove(results,recursive=TRUE,include.dirs = TRUE)
results <- file.remove(c(program,dependencyDir))
return(c(results,inside.out,results))
}
run.program("read_data.R")
run.program("read_data.R")
run.program("read_data.R")
run.program(rscript="read_data.R")
source('~/Documents/Projects/adapr/R/run_Program.R')
run.program(r="read_data.R")
remove.project("Hello1")
get.project.path("Hello1")
init.project("Hello1")
init.project("Hello1")
get_orchard()
file.remove(get.project.path("Hello1"),recursive=TRUE)
init.project("Hello1")
file.remove(get.project.path("Hello1"),recursive=TRUE)
get.project.path("Hello1")
init.project("Hello1")
get_orchard()
remove.project("Hello1")
init.project("Hello1")
set.project("Hello1")
list.programs()
run.program(rscript="read_data.R")
get.project.path("Hello1")
file.remove(get.project.path("Hello1"),recursive=TRUE)
remove.project("Hello1")
init.project("Hello1")
repos.dir <- get.project.path("Hello1")
git2r::commits(git2r::repository(source_info$project.path))
repos.dir <- get.project.path("Hello1")
repos.dir
git2r::commits(git2r::repository(repos.dir))
? file.remove
repos.dir <- get.project.path("Hello1")
git2r::commits(git2r::repository(repos.dir))
remove.project("Hello1")
init.project("Hello1")
git2r::commits(git2r::repository(repos.dir))
length(git2r::commits(git2r::repository(repos.dir)))
commit.project("Hello1" ,"Initialize git")
remove.project("Hello1")
init.project("Hello1")
remove.project("Hello1")
init.project("Hello1")
set.project("Hello1")
length(git2r::commits(git2r::repository(repos.dir)))
plant.tree
git2r::init(project.path)
git.add(project.path,file.path(source.file.info[["path"]],source.file.info[["file"]]))
commit.project(project.id ,"Initialize git")
project.path <- get.project.path("Hello1")
git2r::init(project.path)
init.project("Hello1")
remove.project()
remove.project("Hello1")
init.project("Hello1")
repos.dir <- get.project.path("Hello1")
repos.dir
length(git2r::commits(git2r::repository(repos.dir)))
git2r::init(project.path)
length(git2r::commits(git2r::repository(repos.dir)))
git.add(repos.dir,file.path(repos.dir,"Programs/read_data.R"))
commit.project(project.id ,"Initialize git")
git.add(repos.dir,file.path(repos.dir,"Programs/read_data.R"))
commit.project(project.id ,"Initialize git")
? commit
? init
git.add(repos.dir,file.path(repos.dir,"Programs/read_data.R"))
commit.project(project.id ,"Initialize git")
project.id
project.id <- "Hello1"
repos.dir <- get.project.path("Hello1")
git2r::init(project.path)
length(git2r::commits(git2r::repository(repos.dir)))
git.add(repos.dir,file.path(repos.dir,"Programs/read_data.R"))
commit.project(project.id ,"Initialize git")
source('~/Documents/Projects/adapr/R/intialize.dependency.info.R')
library(adapr)
remove.project("Hello1")
init.project("Hello1")
repos.dir <- get.project.path("Hello1")
project.path <- repos.dir
git2r::init(project.path)
git.add(repos.dir,file.path(repos.dir,"Programs/read_data.R"))
commit.project(project.id ,"Initialize git")
get_adapr_options()
is.null(git2r::discover_repository(project.path)
)
remove.project("Hello1")
init.project("Hello1")
set.project("Hello1")
project.id <- "Hello1"
repos.dir <- get.project.path("Hello1")
project.path <- repos.dir
is.null(git2r::discover_repository(project.path))
git2r::init(project.path)
git.add(project.path,file.path(source.file.info[["path"]],source.file.info[["file"]]))
commit.project(project.id ,"Initialize git")
commit.project(project.id ,"Initialize git")
rm(list=ls())
set.seed( 2011 )
library(adapr)
source.file <-"read_data.R"
project.id <- "Hello1"
project.id0 <- project.id
source.file0 <- source.file
source.description <- "dfsd"
set.project(project.id0,TRUE)
project.path <- get.project.path(project.id0)
project.tree <- project.directory.tree
analysis.dir <- file.path(project.path,project.tree$analysis) # where the programs are
data.dir <- file.path(project.path,project.tree$data)  # where the data are
results.dir <- file.path(project.path,project.tree$results,source.file0) # Standard output
tex.dir <- file.path(results.dir,project.directory.tree$tex.dir) # Publication quality output
dependency.dir <- file.path(project.path,project.tree$dependency.dir)
support.dir <- file.path(project.path,project.tree$support)
library.dir <- file.path(support.dir,project.tree$library.bank)
source.support.dir <- file.path(support.dir,gsub("\\.(R|r)$","_R",source.file0))
apps.dir <- file.path(support.dir,"Apps")
markdown.dir <- file.path(analysis.dir,"Markdown")
project.tree <- project.directory.tree
if(!grepl("\\.R$|\\.r$",source.file0)){stop(paste("Project",project.id0,"Source file",source.file0,"not an R file extension"))}
if(!file.exists(file.path(analysis.dir,source.file0))){stop(paste("Project",project.id0,"Source file",source.file0,"does not exist in program directory"))}
# Create necessary directories
apply(matrix(c(analysis.dir,data.dir,results.dir,tex.dir,dependency.dir,support.dir,library.dir,apps.dir,source.support.dir,markdown.dir   )),1,dir.create,showWarnings=FALSE,recursive=TRUE)
source.file.info <- Create.file.info(analysis.dir,source.file0,description=source.description)
source_info <- list(analysis.dir=analysis.dir,data.dir=data.dir,tex.dir=tex.dir,results.dir=results.dir,support.dir = support.dir,library.dir=library.dir,
dependency.dir=dependency.dir,file=source.file.info,source.support.dir=source.support.dir,markdown.dir=markdown.dir,support.library.file="common_libs.csv")
source_info$project.id <- project.id0
source_info$project.path <- project.path
source_info$options <- get_adapr_options(TRUE)
try({
treedf <- Harvest.trees(dependency.dir)
not.this.source <- subset(treedf,(treedf$source.file!=source_info$file[["file"]])&(!is.na(dependency)))
if (nrow(not.this.source)){source_info$all.files<- Condense.file.info(not.this.source)}
},silent=TRUE)
source_info$dependency.file <- paste(source.file.info[2],".txt",sep="")
source_info$git.path <- source_info$options$git.path
source_info$git.log <- ifelse(is.null(source_info$options$git),TRUE,source_info$options$git=="TRUE")
source_info$dependency <- dependency(data= data.frame())
source_info$options$git <- ifelse(is.null(source_info$options$git),TRUE,source_info$options$git=="TRUE")
source_info_arg <- source_info
source.file.info <- source_info_arg$file
project.path <- source_info_arg$project.path
project.id <- source_info_arg$project.id
dependency.path <- source_info_arg$dependency.dir
dependency.file <- file.path(source_info_arg$dependency.dir,source_info_arg$dependency.file)  #file.path(dependency.path,paste(source.file.info[2],".txt",sep=""))
dependency.out <- data.frame(source.file.path=source.file.info[["path"]],source.file=source.file.info[["file"]],source.file.description=source.file.info[["description"]],
source.run.time=as.POSIXct(Sys.time(),tz = Sys.timezone()),
path=dependency.path,project.path=project.path,project.id=project.id,
target.path=NA,
target.file=NA,
dependency=NA,
target.description=NA,
stringsAsFactors=FALSE)
source_info_arg$dependency$update(dependency.out)
#  write.dependency(dependency.out,dependency.file)
source_info_arg$options$git
is.null(git2r::discover_repository(project.path))
is.null(git2r::discover_repository(project.path))
git.info
git.info(project.path,file.path(project.path,"Programs/read_data.R"))
discover_repository(project.path)
length(git2r::commits(git2r::repository(repos.dir)))
project.path <- repos.dir
project.id <- "Hello1"
repos.dir <- get.project.path("Hello1")
is.null(git2r::discover_repository(project.path))
project.path <- repos.dir
length(git2r::commits(git2r::repository(repos.dir)))
git2r::discover_repository(project.path))
git2r::discover_repository(project.path)
source('~/Documents/Projects/adapr/R/intialize.dependency.info.R')
library(adapr)
remove.project("Hello1")
init.project("Hello1")
dependency.dir
source_info$dependency.dir
list.files(dependency.dir)
run.program(r="read_data.R")
rm(list=ls())
set.seed( 2011 )
library(adapr)
source.file <-"read_data.R"
project.id <- "Hello1"
source_info <- create_source_file_dir(source.description="reads data")
dependency.out <- finalize_dependency()
rm(list=ls())
set.seed( 2011 )
library(adapr)
source.file <-"read_data.R"
project.id <- "Hello1"
source.description=""
set.project(project.id0,TRUE)
project.path <- get.project.path(project.id0)
project.tree <- project.directory.tree
analysis.dir <- file.path(project.path,project.tree$analysis) # where the programs are
data.dir <- file.path(project.path,project.tree$data)  # where the data are
results.dir <- file.path(project.path,project.tree$results,source.file0) # Standard output
tex.dir <- file.path(results.dir,project.directory.tree$tex.dir) # Publication quality output
dependency.dir <- file.path(project.path,project.tree$dependency.dir)
support.dir <- file.path(project.path,project.tree$support)
library.dir <- file.path(support.dir,project.tree$library.bank)
source.support.dir <- file.path(support.dir,gsub("\\.(R|r)$","_R",source.file0))
apps.dir <- file.path(support.dir,"Apps")
markdown.dir <- file.path(analysis.dir,"Markdown")
project.tree <- project.directory.tree
if(!grepl("\\.R$|\\.r$",source.file0)){stop(paste("Project",project.id0,"Source file",source.file0,"not an R file extension"))}
if(!file.exists(file.path(analysis.dir,source.file0))){stop(paste("Project",project.id0,"Source file",source.file0,"does not exist in program directory"))}
# Create necessary directories
apply(matrix(c(analysis.dir,data.dir,results.dir,tex.dir,dependency.dir,support.dir,library.dir,apps.dir,source.support.dir,markdown.dir   )),1,dir.create,showWarnings=FALSE,recursive=TRUE)
source.file.info <- Create.file.info(analysis.dir,source.file0,description=source.description)
source_info <- list(analysis.dir=analysis.dir,data.dir=data.dir,tex.dir=tex.dir,results.dir=results.dir,support.dir = support.dir,library.dir=library.dir,
dependency.dir=dependency.dir,file=source.file.info,source.support.dir=source.support.dir,markdown.dir=markdown.dir,support.library.file="common_libs.csv")
source_info$project.id <- project.id0
source_info$project.path <- project.path
source_info$options <- get_adapr_options(TRUE)
try({
treedf <- Harvest.trees(dependency.dir)
not.this.source <- subset(treedf,(treedf$source.file!=source_info$file[["file"]])&(!is.na(dependency)))
if (nrow(not.this.source)){source_info$all.files<- Condense.file.info(not.this.source)}
},silent=TRUE)
source_info$dependency.file <- paste(source.file.info[2],".txt",sep="")
source_info$git.path <- source_info$options$git.path
source_info$git.log <- ifelse(is.null(source_info$options$git),TRUE,source_info$options$git=="TRUE")
# create depedency ref class instance
source_info$dependency <- dependency(data= data.frame())
source_info$options$git <- ifelse(is.null(source_info$options$git),TRUE,source_info$options$git=="TRUE")
project.id0 <- project.id
source.file0 <- "read_data.R"
set.project(project.id0,TRUE)
project.path <- get.project.path(project.id0)
project.tree <- project.directory.tree
analysis.dir <- file.path(project.path,project.tree$analysis) # where the programs are
data.dir <- file.path(project.path,project.tree$data)  # where the data are
results.dir <- file.path(project.path,project.tree$results,source.file0) # Standard output
tex.dir <- file.path(results.dir,project.directory.tree$tex.dir) # Publication quality output
dependency.dir <- file.path(project.path,project.tree$dependency.dir)
support.dir <- file.path(project.path,project.tree$support)
library.dir <- file.path(support.dir,project.tree$library.bank)
source.support.dir <- file.path(support.dir,gsub("\\.(R|r)$","_R",source.file0))
apps.dir <- file.path(support.dir,"Apps")
markdown.dir <- file.path(analysis.dir,"Markdown")
project.tree <- project.directory.tree
if(!grepl("\\.R$|\\.r$",source.file0)){stop(paste("Project",project.id0,"Source file",source.file0,"not an R file extension"))}
if(!file.exists(file.path(analysis.dir,source.file0))){stop(paste("Project",project.id0,"Source file",source.file0,"does not exist in program directory"))}
# Create necessary directories
apply(matrix(c(analysis.dir,data.dir,results.dir,tex.dir,dependency.dir,support.dir,library.dir,apps.dir,source.support.dir,markdown.dir   )),1,dir.create,showWarnings=FALSE,recursive=TRUE)
source.file.info <- Create.file.info(analysis.dir,source.file0,description=source.description)
source_info <- list(analysis.dir=analysis.dir,data.dir=data.dir,tex.dir=tex.dir,results.dir=results.dir,support.dir = support.dir,library.dir=library.dir,
dependency.dir=dependency.dir,file=source.file.info,source.support.dir=source.support.dir,markdown.dir=markdown.dir,support.library.file="common_libs.csv")
source_info$project.id <- project.id0
source_info$project.path <- project.path
source_info$options <- get_adapr_options(TRUE)
try({
treedf <- Harvest.trees(dependency.dir)
not.this.source <- subset(treedf,(treedf$source.file!=source_info$file[["file"]])&(!is.na(dependency)))
if (nrow(not.this.source)){source_info$all.files<- Condense.file.info(not.this.source)}
},silent=TRUE)
source_info$dependency.file <- paste(source.file.info[2],".txt",sep="")
source_info$git.path <- source_info$options$git.path
source_info$git.log <- ifelse(is.null(source_info$options$git),TRUE,source_info$options$git=="TRUE")
# create depedency ref class instance
source_info$dependency <- dependency(data= data.frame())
source_info$options$git <- ifelse(is.null(source_info$options$git),TRUE,source_info$options$git=="TRUE")
source_info_arg  <- source_info
source.file.info <- source_info_arg$file
project.path <- source_info_arg$project.path
project.id <- source_info_arg$project.id
dependency.path <- source_info_arg$dependency.dir
dependency.file <- file.path(source_info_arg$dependency.dir,source_info_arg$dependency.file)  #file.path(dependency.path,paste(source.file.info[2],".txt",sep=""))
dependency.out <- data.frame(source.file.path=source.file.info[["path"]],source.file=source.file.info[["file"]],source.file.description=source.file.info[["description"]],
source.run.time=as.POSIXct(Sys.time(),tz = Sys.timezone()),
path=dependency.path,project.path=project.path,project.id=project.id,
target.path=NA,
target.file=NA,
dependency=NA,
target.description=NA,
stringsAsFactors=FALSE)
source_info_arg$dependency$update(dependency.out)
source_info_arg$options$git
no.repository <- TRUE
try({
no.repository <- (0==length(git2r::commits(git2r::repository(project.path))))
})
no.repository
git2r::init(project.path)
git.add(project.path,file.path(source.file.info[["path"]],source.file.info[["file"]]))
commit.project(project.id ,"Initialize git")
source.file.info[["path"]]
commit.message=""
source_info <- pull_source_info(project.id)
test.sync0 <- sync.test.si(source_info)$synchronized
synccheck <- ifelse(test.sync0,"SYNCHRONIZED","NOT SYNCd")
setwd(source_info$project.path)
repo <- git2r::repository(source_info$project.path)
analysis.dir <- file.path(source_info$project.path,project.directory.tree$analysis)
all.programs <- matrix(list.files(analysis.dir,recursive=TRUE,full.names=TRUE))
add <-  apply(all.programs,1,function(x){git.add(source_info$project.path,filename=x)})
committed <- git2r::commit(repo,message =paste(synccheck,commit.message))
out <- paste("Git",commit2char(committed))
library(adapr)
remove.project("Hello1")
init.project("Hello1")
remove.project("Hello1")
library(adapr)
init.project("Hello1")
remove.project("Hello1")
library(adapr)
init.project("Hello1")
commit.project()
commit.project
source('~/Documents/Projects/adapr/R/intialize.dependency.info.R')
library(adapr)
remove.project("Hello1")
init.project("Hello1")
library(adapr)
devtools::load_all()
library(adapr)
init.project("Hello2")
init.project("Morilak_343")
set.project("Morilak_343")
show.project()
library(adapr)
ls()
rm(list=ls())
library(adapr)
library(adapr)
library(adapr)
sync.project()
library(adapr)
library(adapr)
library(adapr)
library(adapr)
library(adapr)
library("acepack", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
detach("package:acepack", unload=TRUE)
library(adapr)
library(adapr)
ls()
rm(list=ls())
library(adapr)
run.program
?report.project()
report.project
project_report_markdown
report.project
pull_source_info("adaprHome")
library(adapr)
commit.project
git.add
