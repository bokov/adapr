#	par(mfrow=c(1,2))
#	plot(dagger,main="Dagger with time as color")
dagger.updated <- dagger
V(dagger.updated)$color <- ifelse(V(dagger.updated)$name %in% vertex.updates,"red","white")
if(plotl){plot(dagger.updated,main="Dagger with out of sync detection")}
# check for file hash inconsistencies
file.check <- Check.file.hash(dependency.object=tree)
file.info <- Condense.file.info(tree)
# get the abbreviated names from the tree to match to the vertex
if(file.check$hash.fail){
all.fail <- rbind.fill(file.check$stale.hash,file.check$multiple.hash)
failed.tree <- merge(all.fail,file.info,by=c("file","path"))
print("Hash fails")
print(failed.tree)
failed.fullname.abbr <- failed.tree$fullname.abbr
vertex.updates <- unique(c(vertex.updates,failed.fullname.abbr))
}
# Propagate dependencies
updated.vertex.dependency <- c()
for(vertex.updates.iter in vertex.updates){
print(vertex.updates.iter)
if(!(vertex.updates.iter  %in% updated.vertex.dependency)){
children <- V(dagger.updated)$name[na.exclude(graph.bfs(dagger,vertex.updates.iter,unreachable=FALSE)$order)]
updated.vertex.dependency <- union(children,updated.vertex.dependency)
}
}
dagger.propagated <- dagger
V(dagger.propagated)$color <- ifelse(V(dagger.propagated)$name %in% updated.vertex.dependency,"red","white")
V(dagger.propagated)$synced <- ifelse(V(dagger.propagated)$name %in% updated.vertex.dependency,"No","Yes")
stale.graph <- induced.subgraph(dagger.propagated,V(dagger.updated)[V(dagger.updated)$name %in% updated.vertex.dependency],impl="create_from_scratch")
sources.to.sync <- ID.sync(file.info,stale.graph)
stale.graph <- induced.subgraph(dagger.propagated,V(dagger.updated)[V(dagger.updated)$name %in% updated.vertex.dependency],impl="create_from_scratch")
sources.to.sync <- ID.sync(file.info,stale.graph)
stale.graph
stale.graph
V(stale.graph)
length(V(stale.graph))
stale.graph <- induced.subgraph(dagger.propagated,V(dagger.updated)[V(dagger.updated)$name %in% updated.vertex.dependency],impl="create_from_scratch")
dag.to.sync <- stale.graph
run.order <- topological.sort(dag.to.sync)
run.order
run.order <- topological.sort(dag.to.sync)
repair.sync.file.info <- subset(data.frame(fullname.abbr=V(dag.to.sync)$name,file.class=V(dag.to.sync)$file.class,
file=V(dag.to.sync)$file,path=V(dag.to.sync)$path)[run.order,],file.class=="source")
repair.sync.file.info$run.order <- 1:nrow(repair.sync.file.info)
repair.sync.file.info
run.order <- topological.sort(dag.to.sync)
repair.sync.file.info <- subset(data.frame(fullname.abbr=V(dag.to.sync)$name,file.class=V(dag.to.sync)$file.class,
file=V(dag.to.sync)$file,path=V(dag.to.sync)$path)[run.order,],file.class=="source")
repair.sync.file.info$run.order <- 1:nrow(repair.sync.file.info)
1:nrow(repair.sync.file.info)
repair.sync.file.info$run.order
repair.sync.file.info$run.order <- integer(0)
repair.sync.file.info
load_all()
load_all()
library(adapr)
shinyTree()
source_info <- pull_source_info("test_adapr")
source_info
test.sync0 <- sync.test.si(source_info)
test.sync0
sync.test.si
dagger
tree
dagger <- get.project.info.si(pull_source_info("test_adapr"))
tree <- dagger$tree
dagger <- dagger$graph
load_all()
library(devtools)
library(adapr)
shinyTree()
dagger <- get.project.info.si(pull_source_info("test_adapr"))
tree <- dagger$tree
dagger <- dagger$graph
if(!is.dag(dagger)){stop("The computing dependencies have cycles.")}
# track the run time of source files
# track the modification time of target files
V(dagger)$time <- ifelse(V(dagger)$file.class=="source",V(dagger)$run.time,V(dagger)$mod.time)
children.list <- get.adjlist(dagger,mode="out")
updated.logical <- matrix(FALSE,length(children.list),1,dimnames=list(V(dagger)$name,"time"))
# find the out dated nodes
parent <- names(children.list)[1]
for(parent in names(children.list)){
if(length(children.list[[parent]])>0){
parent.time <- V(dagger)$time[V(dagger)$name==parent]
min.child.time <- min(V(dagger)$time[children.list[[parent]]])
updated.logical[parent,] <- parent.time > min.child.time
if(parent.time > min.child.time){
print(paste("Parent younger than child:","Parent =",parent,parent.time))
child.times <- subset(data.frame(child=V(dagger)$name[children.list[[parent]]], time=V(dagger)$time[children.list[[parent]]]),time<parent.time)
print("Child times")
print(child.times)
}
}
}
vertex.updates <- rownames(updated.logical)[updated.logical]
V(dagger)$color <- "blue"
#	par(mfrow=c(1,2))
#	plot(dagger,main="Dagger with time as color")
dagger.updated <- dagger
V(dagger.updated)$color <- ifelse(V(dagger.updated)$name %in% vertex.updates,"red","white")
if(plotl){plot(dagger.updated,main="Dagger with out of sync detection")}
# check for file hash inconsistencies
file.check <- Check.file.hash(dependency.object=tree)
file.info <- Condense.file.info(tree)
# get the abbreviated names from the tree to match to the vertex
if(file.check$hash.fail){
all.fail <- rbind.fill(file.check$stale.hash,file.check$multiple.hash)
failed.tree <- merge(all.fail,file.info,by=c("file","path"))
print("Hash fails")
print(failed.tree)
failed.fullname.abbr <- failed.tree$fullname.abbr
vertex.updates <- unique(c(vertex.updates,failed.fullname.abbr))
}
# combine file modification time inconsistencies with file hash inconsistencies
# if target output is out of sync then update the
# source file that creates it
if(length(vertex.updates)>0){
updated.vertex.info <- subset(file.info,fullname.abbr %in% vertex.updates)
updated.vertex.info$target.path <- updated.vertex.info$path
updated.vertex.info$target.file <- updated.vertex.info$file
failed.tree.2 <- merge(updated.vertex.info,tree,by=c("target.file","target.path"))
source.for.targets <- subset(file.info,file==unique(subset(failed.tree.2,dependency=="out")$source.file))$fullname.abbr
}else{return(list(synchronized=TRUE))}
vertex.updates <- unique(c(vertex.updates,source.for.targets))
# Propagate dependencies
updated.vertex.dependency <- c()
for(vertex.updates.iter in vertex.updates){
print(vertex.updates.iter)
if(!(vertex.updates.iter  %in% updated.vertex.dependency)){
children <- V(dagger.updated)$name[na.exclude(graph.bfs(dagger,vertex.updates.iter,unreachable=FALSE)$order)]
updated.vertex.dependency <- union(children,updated.vertex.dependency)
}
}
dagger.propagated <- dagger
V(dagger.propagated)$color <- ifelse(V(dagger.propagated)$name %in% updated.vertex.dependency,"red","white")
V(dagger.propagated)$synced <- ifelse(V(dagger.propagated)$name %in% updated.vertex.dependency,"No","Yes")
#	plot(dagger.updated,main="dagger")
#	plot(dagger.propagated,main="propagate")
#	par(mfrow=c(1,1))
stale.graph <- induced.subgraph(dagger.propagated,V(dagger.updated)[V(dagger.updated)$name %in% updated.vertex.dependency],impl="create_from_scratch")
sources.to.sync <- ID.sync(file.info,stale.graph)
ifelse(nrow(sources.to.sync)>0,FALSE,TRUE)
load_all()
library(adapr)
shinyTree()
si <- pull_source_info(project.id)
projinfo <- get.project.info.si(si)
unsync.vertex <- c("",as.character(sync.test.si(si)$sources.to.sync$fullname.abbr))
projgraph <- projinfo$graph
sources <- unique(projinfo$tree$source.file)
vertexnames <- subset(projinfo$all.files,file %in%sources)$fullname.abbr
if(length(vertexnames)==1){
dfo <- data.frame(v=vertexnames[1],x=0,y=0)
text.nudge0 <- 0.15
dotsize0 <- 10
text.size0 <- 10
dfo$synccolor <- ifelse(dfo$v %in% unsync.vertex,"red","skyblue")
proj.gg <- ggplot(dfo,aes(x=x,y=y,label=basename(as.character(v))))+geom_text(nudge_y=text.nudge0,size=text.size0,color="red")+geom_point(color=dfo$synccolor,size=10,alpha=0.5)+scale_x_continuous(limits=c(-1,1))+scale_y_continuous(limits=c(-1,1))+theme(axis.line=element_blank(),axis.text.x=element_blank(),
axis.text.y=element_blank(),axis.ticks=element_blank(),
axis.title.x=element_blank(),
axis.title.y=element_blank(),legend.position="none",
panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),plot.background=element_blank())+ggtitle(paste(project.id,"R Script Graph"))
isg <- induced_subgraph(projgraph,vertexnames)
return(list(vertex=dfo ,edges=NA,ggplot=proj.gg,rgrapher=isg))
}
lo <- layout.sugiyama(projgraph)
tp <- function(x){
x <- x[,2:1]
x[,1] <- max(x[,1])- x[,1]
return(x)
}
vertex <- vertexnames[2]
vertexTo <- vertexnames[4]
longgraph <- NULL
for(vertex in vertexnames){
shortgraph <- data.frame(from=vertex,to=vertex)
tos <- c()
for(vertexTo in vertexnames){
shortguy <- shortest_paths(projgraph,vertex,vertexTo)
if(length(shortguy$vpath[[1]])==3){
tos <- c(vertexTo,tos)
}# if one step path
}# loop over targets
if(length(tos)>0){
shortgraph <- rbind(shortgraph,data.frame(from=vertex,to=tos))
}# if any targets connected
longgraph <- rbind(longgraph,shortgraph)
}
isg <- simplify(graph.data.frame(longgraph))
#plot(isg)
#plot(isg,layout=tp(layout.sugiyama(isg)$layout))
isgdf <- igraph::as_data_frame(isg)
dfo <- tp(layout.sugiyama(isg)$layout)
colnames(dfo) <- c("x","y")
dfo <- data.frame(dfo,v=V(isg)$name)
todfo <- dfo
names(todfo)[1:2] <- c("x2","y2")
tos <- merge(isgdf,todfo,by.x="to",by.y="v")
froms <- merge(tos,dfo,by.x="from",by.y="v")
ranger <- range(c(froms$x,froms$x2))
span <- 0.1*abs(diff(ranger))
horizontal.range <- c(ranger[1]-span,ranger[2]+span)
rangery <- range(c(froms$y,froms$y2))
graph.height <- length(unique(c(froms$y,froms$y2)))
graph.width <- length(unique(c(froms$y,froms$y2)))
dotsize0 <- if(graph.height>5){dot.size <-1+10/graph.height}else{dot.size0 <- 10}
text.nudge0 <- 0.05*abs(diff(rangery))
if(graph.height>5){text.nudge0 <-text.nudge0/graph.height}
text.size0 <- 5
if(graph.width>5){text.size0 <-2 + 2*text.size0/graph.width}
dfo$synccolor <- as.character(ifelse(dfo$v %in% unsync.vertex,"red","skyblue"))
proj.gg <- ggplot(dfo,aes(x=x,y=y,label=basename(as.character(v))))+geom_text(nudge_y=text.nudge0,size=text.size0,color="red")+geom_point(color=dfo$synccolor,size=dotsize0,alpha=0.5)+
annotate(geom="segment",x=froms$x,y=froms$y,xend=froms$x2,yend=froms$y2,arrow=arrow(length=unit(0.2,"cm"),type="closed"),alpha=0.5/ifelse(graph.width>5,5,1))+
scale_x_continuous(limits=horizontal.range)+theme(axis.line=element_blank(),axis.text.x=element_blank(),
axis.text.y=element_blank(),axis.ticks=element_blank(),
axis.title.x=element_blank(),
axis.title.y=element_blank(),legend.position="none",
panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),plot.background=element_blank())+ggtitle(paste(project.id,"R Script Graph"))
return(list(vertex=dfo,edges=froms,ggplot=proj.gg,rgrapher=isg))
froms
project.id
# computes transitively connected subpgraph of project DAG
# given a project id (project.id)
#
require(ggplot2)
require(plyr)
si <- pull_source_info(project.id)
projinfo <- get.project.info.si(si)
unsync.vertex <- c("",as.character(sync.test.si(si)$sources.to.sync$fullname.abbr))
projgraph <- projinfo$graph
sources <- unique(projinfo$tree$source.file)
vertexnames <- subset(projinfo$all.files,file %in%sources)$fullname.abbr
if(length(vertexnames)==1){
dfo <- data.frame(v=vertexnames[1],x=0,y=0)
text.nudge0 <- 0.15
dotsize0 <- 10
text.size0 <- 10
dfo$synccolor <- ifelse(dfo$v %in% unsync.vertex,"red","skyblue")
proj.gg <- ggplot(dfo,aes(x=x,y=y,label=basename(as.character(v))))+geom_text(nudge_y=text.nudge0,size=text.size0,color="red")+geom_point(color=dfo$synccolor,size=10,alpha=0.5)+scale_x_continuous(limits=c(-1,1))+scale_y_continuous(limits=c(-1,1))+theme(axis.line=element_blank(),axis.text.x=element_blank(),
axis.text.y=element_blank(),axis.ticks=element_blank(),
axis.title.x=element_blank(),
axis.title.y=element_blank(),legend.position="none",
panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),plot.background=element_blank())+ggtitle(paste(project.id,"R Script Graph"))
isg <- induced_subgraph(projgraph,vertexnames)
return(list(vertex=dfo ,edges=NA,ggplot=proj.gg,rgrapher=isg))
}
lo <- layout.sugiyama(projgraph)
tp <- function(x){
x <- x[,2:1]
x[,1] <- max(x[,1])- x[,1]
return(x)
}
vertex <- vertexnames[2]
vertexTo <- vertexnames[4]
longgraph <- NULL
for(vertex in vertexnames){
shortgraph <- data.frame(from=vertex,to=vertex)
tos <- c()
for(vertexTo in vertexnames){
shortguy <- shortest_paths(projgraph,vertex,vertexTo)
if(length(shortguy$vpath[[1]])==3){
tos <- c(vertexTo,tos)
}# if one step path
}# loop over targets
if(length(tos)>0){
shortgraph <- rbind(shortgraph,data.frame(from=vertex,to=tos))
}# if any targets connected
longgraph <- rbind(longgraph,shortgraph)
}
isg <- simplify(graph.data.frame(longgraph))
#plot(isg)
#plot(isg,layout=tp(layout.sugiyama(isg)$layout))
isgdf <- igraph::as_data_frame(isg)
dfo <- tp(layout.sugiyama(isg)$layout)
colnames(dfo) <- c("x","y")
dfo <- data.frame(dfo,v=V(isg)$name)
todfo <- dfo
names(todfo)[1:2] <- c("x2","y2")
tos <- merge(isgdf,todfo,by.x="to",by.y="v")
froms <- merge(tos,dfo,by.x="from",by.y="v")
ranger <- range(c(froms$x,froms$x2))
span <- 0.1*abs(diff(ranger))
horizontal.range <- c(ranger[1]-span,ranger[2]+span)
rangery <- range(c(froms$y,froms$y2))
graph.height <- length(unique(c(froms$y,froms$y2)))
graph.width <- length(unique(c(froms$y,froms$y2)))
dotsize0 <- if(graph.height>5){dot.size <-1+10/graph.height}else{dot.size0 <- 10}
text.nudge0 <- 0.05*abs(diff(rangery))
if(graph.height>5){text.nudge0 <-text.nudge0/graph.height}
text.size0 <- 5
if(graph.width>5){text.size0 <-2 + 2*text.size0/graph.width}
dfo$synccolor <- as.character(ifelse(dfo$v %in% unsync.vertex,"red","skyblue"))
proj.gg <- ggplot(dfo,aes(x=x,y=y,label=basename(as.character(v))))+geom_text(nudge_y=text.nudge0,size=text.size0,color="red")+geom_point(color=dfo$synccolor,size=dotsize0,alpha=0.5)+
annotate(geom="segment",x=froms$x,y=froms$y,xend=froms$x2,yend=froms$y2,arrow=arrow(length=unit(0.2,"cm"),type="closed"),alpha=0.5/ifelse(graph.width>5,5,1))+
scale_x_continuous(limits=horizontal.range)+theme(axis.line=element_blank(),axis.text.x=element_blank(),
axis.text.y=element_blank(),axis.ticks=element_blank(),
axis.title.x=element_blank(),
axis.title.y=element_blank(),legend.position="none",
panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),plot.background=element_blank())+ggtitle(paste(project.id,"R Script Graph"))
dfo
projinfo
dfo <- merge(dfo,subset(projinfo$all.files,select=c("fullname.abbr","fullname"),by.x="v",by.y="fullname.abbr"))
dfo
dfo <- data.frame(v=vertexnames[1],x=0,y=0)
dfo
text.nudge0 <- 0.15
dotsize0 <- 10
text.size0 <- 10
dfo$synccolor <- ifelse(dfo$v %in% unsync.vertex,"red","skyblue")
dfo
proj.gg <- ggplot(dfo,aes(x=x,y=y,label=basename(as.character(v))))+geom_text(nudge_y=text.nudge0,size=text.size0,color="red")+geom_point(color=dfo$synccolor,size=10,alpha=0.5)+scale_x_continuous(limits=c(-1,1))+scale_y_continuous(limits=c(-1,1))+theme(axis.line=element_blank(),axis.text.x=element_blank(),
axis.text.y=element_blank(),axis.ticks=element_blank(),
axis.title.x=element_blank(),
axis.title.y=element_blank(),legend.position="none",
panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),plot.background=element_blank())+ggtitle(paste(project.id,"R Script Graph"))
isg <- induced_subgraph(projgraph,vertexnames)
dfo <- merge(dfo,subset(projinfo$all.files,select=c("fullname.abbr","fullname"),by.x="v",by.y="fullname.abbr"))
dfo
source('~/Documents/Projects/adapr/R/create_program_graph.R')
source('~/Documents/Projects/adapr/R/create_program_graph.R')
temp <- create_program_graph("test_adapr")
temp$vertex
temp$ggplot
project.id <- "test_adapr"
require(ggplot2)
require(plyr)
si <- pull_source_info(project.id)
projinfo <- get.project.info.si(si)
unsync.vertex <- c("",as.character(sync.test.si(si)$sources.to.sync$fullname.abbr))
projgraph <- projinfo$graph
sources <- unique(projinfo$tree$source.file)
vertexnames <- subset(projinfo$all.files,file %in%sources)$fullname.abbr
if(length(vertexnames)==1){
dfo <- data.frame(v=vertexnames[1],x=0,y=0)
text.nudge0 <- 0.15
dotsize0 <- 10
text.size0 <- 10
dfo$synccolor <- ifelse(dfo$v %in% unsync.vertex,"red","skyblue")
proj.gg <- ggplot(dfo,aes(x=x,y=y,label=basename(as.character(v))))+geom_text(nudge_y=text.nudge0,size=text.size0,color="red")+geom_point(color=dfo$synccolor,size=10,alpha=0.5)+scale_x_continuous(limits=c(-1,1))+scale_y_continuous(limits=c(-1,1))+theme(axis.line=element_blank(),axis.text.x=element_blank(),
axis.text.y=element_blank(),axis.ticks=element_blank(),
axis.title.x=element_blank(),
axis.title.y=element_blank(),legend.position="none",
panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),plot.background=element_blank())+ggtitle(paste(project.id,"R Script Graph"))
isg <- induced_subgraph(projgraph,vertexnames)
dfo <- merge(dfo,subset(projinfo$all.files,select=c("fullname.abbr","fullname"),by.x="v",by.y="fullname.abbr"))
return(list(vertex=dfo ,edges=NA,ggplot=proj.gg,rgrapher=isg))
}
lo <- layout.sugiyama(projgraph)
tp <- function(x){
x <- x[,2:1]
x[,1] <- max(x[,1])- x[,1]
return(x)
}
vertex <- vertexnames[2]
vertexTo <- vertexnames[4]
longgraph <- NULL
for(vertex in vertexnames){
shortgraph <- data.frame(from=vertex,to=vertex)
tos <- c()
for(vertexTo in vertexnames){
shortguy <- shortest_paths(projgraph,vertex,vertexTo)
if(length(shortguy$vpath[[1]])==3){
tos <- c(vertexTo,tos)
}# if one step path
}# loop over targets
if(length(tos)>0){
shortgraph <- rbind(shortgraph,data.frame(from=vertex,to=tos))
}# if any targets connected
longgraph <- rbind(longgraph,shortgraph)
}
isg <- simplify(graph.data.frame(longgraph))
#plot(isg)
#plot(isg,layout=tp(layout.sugiyama(isg)$layout))
isgdf <- igraph::as_data_frame(isg)
dfo <- tp(layout.sugiyama(isg)$layout)
colnames(dfo) <- c("x","y")
dfo <- data.frame(dfo,v=V(isg)$name)
todfo <- dfo
names(todfo)[1:2] <- c("x2","y2")
tos <- merge(isgdf,todfo,by.x="to",by.y="v")
froms <- merge(tos,dfo,by.x="from",by.y="v")
ranger <- range(c(froms$x,froms$x2))
span <- 0.1*abs(diff(ranger))
horizontal.range <- c(ranger[1]-span,ranger[2]+span)
rangery <- range(c(froms$y,froms$y2))
graph.height <- length(unique(c(froms$y,froms$y2)))
graph.width <- length(unique(c(froms$y,froms$y2)))
dotsize0 <- if(graph.height>5){dot.size <-1+10/graph.height}else{dot.size0 <- 10}
text.nudge0 <- 0.05*abs(diff(rangery))
if(graph.height>5){text.nudge0 <-text.nudge0/graph.height}
text.size0 <- 5
if(graph.width>5){text.size0 <-2 + 2*text.size0/graph.width}
dfo$synccolor <- as.character(ifelse(dfo$v %in% unsync.vertex,"red","skyblue"))
proj.gg <- ggplot(dfo,aes(x=x,y=y,label=basename(as.character(v))))+geom_text(nudge_y=text.nudge0,size=text.size0,color="red")+geom_point(color=dfo$synccolor,size=dotsize0,alpha=0.5)+
annotate(geom="segment",x=froms$x,y=froms$y,xend=froms$x2,yend=froms$y2,arrow=arrow(length=unit(0.2,"cm"),type="closed"),alpha=0.5/ifelse(graph.width>5,5,1))+
scale_x_continuous(limits=horizontal.range)+theme(axis.line=element_blank(),axis.text.x=element_blank(),
axis.text.y=element_blank(),axis.ticks=element_blank(),
axis.title.x=element_blank(),
axis.title.y=element_blank(),legend.position="none",
panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),plot.background=element_blank())+ggtitle(paste(project.id,"R Script Graph"))
dfo <- merge(dfo,subset(projinfo$all.files,select=c("fullname.abbr","fullname"),by.x="v",by.y="fullname.abbr"))
dfo
# computes transitively connected subpgraph of project DAG
# given a project id (project.id)
#
require(ggplot2)
require(plyr)
si <- pull_source_info(project.id)
projinfo <- get.project.info.si(si)
unsync.vertex <- c("",as.character(sync.test.si(si)$sources.to.sync$fullname.abbr))
projgraph <- projinfo$graph
sources <- unique(projinfo$tree$source.file)
vertexnames <- subset(projinfo$all.files,file %in%sources)$fullname.abbr
if(length(vertexnames)==1){
dfo <- data.frame(v=vertexnames[1],x=0,y=0)
text.nudge0 <- 0.15
dotsize0 <- 10
text.size0 <- 10
dfo$synccolor <- ifelse(dfo$v %in% unsync.vertex,"red","skyblue")
proj.gg <- ggplot(dfo,aes(x=x,y=y,label=basename(as.character(v))))+geom_text(nudge_y=text.nudge0,size=text.size0,color="red")+geom_point(color=dfo$synccolor,size=10,alpha=0.5)+scale_x_continuous(limits=c(-1,1))+scale_y_continuous(limits=c(-1,1))+theme(axis.line=element_blank(),axis.text.x=element_blank(),
axis.text.y=element_blank(),axis.ticks=element_blank(),
axis.title.x=element_blank(),
axis.title.y=element_blank(),legend.position="none",
panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),plot.background=element_blank())+ggtitle(paste(project.id,"R Script Graph"))
isg <- induced_subgraph(projgraph,vertexnames)
dfo <- merge(dfo,subset(projinfo$all.files,select=c("fullname.abbr","fullname"),by.x="v",by.y="fullname.abbr"))
return(list(vertex=dfo ,edges=NA,ggplot=proj.gg,rgrapher=isg))
}
lo <- layout.sugiyama(projgraph)
tp <- function(x){
x <- x[,2:1]
x[,1] <- max(x[,1])- x[,1]
return(x)
}
vertex <- vertexnames[2]
vertexTo <- vertexnames[4]
longgraph <- NULL
for(vertex in vertexnames){
shortgraph <- data.frame(from=vertex,to=vertex)
tos <- c()
for(vertexTo in vertexnames){
shortguy <- shortest_paths(projgraph,vertex,vertexTo)
if(length(shortguy$vpath[[1]])==3){
tos <- c(vertexTo,tos)
}# if one step path
}# loop over targets
if(length(tos)>0){
shortgraph <- rbind(shortgraph,data.frame(from=vertex,to=tos))
}# if any targets connected
longgraph <- rbind(longgraph,shortgraph)
}
isg <- simplify(graph.data.frame(longgraph))
#plot(isg)
#plot(isg,layout=tp(layout.sugiyama(isg)$layout))
isgdf <- igraph::as_data_frame(isg)
dfo <- tp(layout.sugiyama(isg)$layout)
colnames(dfo) <- c("x","y")
dfo <- data.frame(dfo,v=V(isg)$name)
todfo <- dfo
names(todfo)[1:2] <- c("x2","y2")
tos <- merge(isgdf,todfo,by.x="to",by.y="v")
froms <- merge(tos,dfo,by.x="from",by.y="v")
ranger <- range(c(froms$x,froms$x2))
span <- 0.1*abs(diff(ranger))
horizontal.range <- c(ranger[1]-span,ranger[2]+span)
rangery <- range(c(froms$y,froms$y2))
graph.height <- length(unique(c(froms$y,froms$y2)))
graph.width <- length(unique(c(froms$y,froms$y2)))
dotsize0 <- if(graph.height>5){dot.size <-1+10/graph.height}else{dot.size0 <- 10}
text.nudge0 <- 0.05*abs(diff(rangery))
if(graph.height>5){text.nudge0 <-text.nudge0/graph.height}
text.size0 <- 5
if(graph.width>5){text.size0 <-2 + 2*text.size0/graph.width}
dfo$synccolor <- as.character(ifelse(dfo$v %in% unsync.vertex,"red","skyblue"))
proj.gg <- ggplot(dfo,aes(x=x,y=y,label=basename(as.character(v))))+geom_text(nudge_y=text.nudge0,size=text.size0,color="red")+geom_point(color=dfo$synccolor,size=dotsize0,alpha=0.5)+
annotate(geom="segment",x=froms$x,y=froms$y,xend=froms$x2,yend=froms$y2,arrow=arrow(length=unit(0.2,"cm"),type="closed"),alpha=0.5/ifelse(graph.width>5,5,1))+
scale_x_continuous(limits=horizontal.range)+theme(axis.line=element_blank(),axis.text.x=element_blank(),
axis.text.y=element_blank(),axis.ticks=element_blank(),
axis.title.x=element_blank(),
axis.title.y=element_blank(),legend.position="none",
panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),plot.background=element_blank())+ggtitle(paste(project.id,"R Script Graph"))
dfo
subset(projinfo$all.files,select=c("fullname.abbr","fullname")
)
merge(dfo,subset(projinfo$all.files,select=c("fullname.abbr","fullname")),by.x="v",by.y="fullname.abbr")
source('~/Documents/Projects/adapr/R/create_program_graph.R')
source('~/Documents/Projects/adapr/R/create_program_graph.R')
project.id <- "test_adapr"
temp <- create_program_graph("test_adapr")
temp
source('~/Documents/Projects/adapr/R/create_program_graph.R')
load_all()
library(adapr)
shiny::runApp('/Volumes/WORKING2/Projects/Goros/adapr/inst/Interface2')
install.packages("plotly")
shiny::runApp('/Volumes/WORKING2/Projects/Goros/adapr/inst/Interface2')
install.packages("shinydashboard")
shiny::runApp('/Volumes/WORKING2/Projects/Goros/adapr/inst/Interface2')
library(shinydashboard)
shiny::runApp('/Volumes/WORKING2/Projects/Goros/adapr/inst/Interface2')
shiny::runApp('/Volumes/WORKING2/Projects/Goros/adapr/inst/Interface2')
