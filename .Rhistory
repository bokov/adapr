shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
dir.exists
dir.exists(project.path
)
shinyTree()
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
Check.file.hash
source_info
rm(list=ls())
set.seed( 2011 )
library(adapr)
require(knitr)
source.file <-"read_data.R"
project.id <- "test_adapr"
source_info <- create_source_file_dir(source.description="reads data")
# Program body here
print("Check")
#project_report_send_rmd(target.directory=get.project.publish.path(project.id),source_info,send.data=FALSE, graph.width = 960, graph.height = 500)
ostype <- .Platform$OS.type
topdirs <- list.files(path.expand.2("~"),full.names=TRUE)
project.path <- file.path(grep("Documents$",topdirs,value=1)[1],"Projects")
publish.path <- file.path(project.path,"Publish")
publish.path <- gsub("\\\\","/",publish.path)
project.path <- gsub("\\\\","/",project.path)
#print(publish.path)
#print(project.path)
dir.create(project.path,recursive=TRUE)
dir.create(publish.path,recursive=TRUE)
project.path.start <- ifelse(dir.exists(project.path),project.path,"")
publish.path.start <- ifelse(dir.exists(publish.path),publish.path,"")
# End Program Body
dependency.out <- finalize_dependency()
dependency.dir <- source_info$dependency.dir
trees <- Harvest.trees(dependency.dir)
trees <- subset(trees,!is.na(dependency))
trees
source.df <- subset(trees,!duplicated(source.hash))
source.hash.count <- ddply(source.df,"source.file",function(x){
all.hash <- unique(x$source.hash)
n.unique.hash <- length(unique(all.hash))
out.counts <- data.frame(path=x$source.file.path[1],file=x$source.file[1],n.unique.hash=n.unique.hash,file.hash=all.hash,stringsAsFactors=FALSE)
return(out.counts)
})
source.hash.count
target.hash.count <- ddply(trees,c("target.path","target.file"),function(x){
all.hash <- unique(x$target.hash)
n.unique.hash <- length(unique(all.hash))
out.counts <- data.frame(path=x$target.path[1],file=x$target.file[1],n.unique.hash=n.unique.hash,file.hash=all.hash,stringsAsFactors=FALSE)
return(out.counts)
})
target.hash.count
all.hash.counts <- rbind.fill(source.hash.count,target.hash.count)
multiple.hash <- subset(all.hash.counts,n.unique.hash!=1,select=c("path","file","file.hash","n.unique.hash"))
multiple.hash
hash.compute <- ddply(all.hash.counts,c("path","file","file.hash","n.unique.hash"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$path[1],x$file[1]),serialize=FALSE)
})
out.counts <- data.frame(current.hash=current.hash,stringsAsFactors=FALSE)
return(out.counts)
})
hash.compute
stale.hash <- subset(hash.compute,current.hash!=file.hash)
hash.fail <- as.logical(nrow(multiple.hash)+nrow(stale.hash))
stale.hash
all.hash.counts
trees
trees
trees
source.df <- subset(trees,!duplicated(source.hash))
#Check source hashes are current
source.hash.count <- ddply(source.df,c("source.file","path","file"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$path[1],x$file[1]),serialize=FALSE)
})
x$hash.fail <- current.hash != x$target.hash
return(out.counts)
})
source.df <- subset(trees,!duplicated(source.hash))
#Check source hashes are current
source.hash.count <- ddply(source.df,c("source.file","path","file"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$path[1],x$file[1]),serialize=FALSE)
})
x$hash.fail <- current.hash != x$target.hash
return(out.counts)
})
source.df
source.hash.count <- ddply(source.df,c("source.file","path","file"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$path[1],x$file[1]),serialize=FALSE)
})
hash.fail <- current.hash != x$target.hash
return(data.frame(hash.fail))
})
source.df
source.df <- subset(trees,!duplicated(source.hash))
#Check source hashes are current
source.hash.count <- ddply(source.df,c("source.file","source.file.path",function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$source.filepath[1],x$source.file[1]),serialize=FALSE)
})
hash.fail <- current.hash != x$target.hash
return(data.frame(hash.fail))
})
source.hash.count <- ddply(source.df,c("source.file","source.file.path"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$source.filepath[1],x$source.file[1]),serialize=FALSE)
})
hash.fail <- current.hash != x$target.hash
return(data.frame(hash.fail))
})
source.df
source.hash.count <- ddply(source.df,c("source.file","source.file.path"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$source.filepath[1],x$source.file[1]),serialize=FALSE)
})
hash.fail <- current.hash != x$source.hash
return(data.frame(hash.fail))
})
source.hash.count <- ddply(source.df,c("source.file","source.file.path"),function(x){
current.hash <- ""
try({
# current.hash <- Digest(file=file.path(x$source.filepath[1],x$source.file[1]),serialize=FALSE)
})
hash.fail <- current.hash != x$source.hash
return(data.frame(hash.fail))
})
source.hash.count <- ddply(source.df,c("source.file","source.file.path"),function(x){
current.hash <- ""
try({
# current.hash <- Digest(file=file.path(x$source.file.path[1],x$source.file[1]),serialize=FALSE)
})
hash.fail <- current.hash != x$source.hash
return(data.frame(hash.fail))
})
source.hash.count
source.hash.count <- ddply(source.df,c("source.file","source.file.path"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$source.file.path[1],x$source.file[1]),serialize=FALSE)
})
hash.fail <- current.hash != x$source.hash
return(data.frame(hash.fail))
})
source.hash.count
target.hash.count <- ddply(trees,c("source.file","source.file.path","target.path","target.file"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$path[1],x$file[1]),serialize=FALSE)
})
x$hash.fail <- current.hash != x$target.hash
return(x)
})
target.hash.count <- ddply(trees,c("source.file","source.file.path","target.path","target.file"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$target.path[1],x$target.file[1]),serialize=FALSE)
})
x$hash.fail <- current.hash != x$target.hash
return(x)
})
target.hash.count
subset(target.hash.check,hash.fail)
target.hash.check <- ddply(trees,c("source.file","source.file.path","target.path","target.file"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$target.path[1],x$target.file[1]),serialize=FALSE)
})
x$hash.fail <- current.hash != x$target.hash
return(x)
})
target.hash.check
failed.sources <- subset(source.hash.check,hash.fail)
#' Checks the consistency of the dependency directory with the files within the file system
#' Reports the source scripts that need to be updated!
#' @param dependency.dir Directory with dependency information files
#' @param dependency.object data frame with dependency information
#' @details Only needs one or the other argument.
#' @return list of information about file hase mismatches
#' @export
#'
Check.file.hash.source <- function(dependency.dir=NULL,dependency.object=NULL){
if(is.null(dependency.object)){
trees <- Harvest.trees(dependency.dir)
trees <- subset(trees,!is.na(dependency))
}else{trees <- dependency.object}
source.df <- subset(trees,!duplicated(source.hash))
#Check source hashes are current
source.hash.check <- ddply(source.df,c("source.file","source.file.path"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$source.file.path[1],x$source.file[1]),serialize=FALSE)
})
hash.fail <- current.hash != x$source.hash
return(data.frame(hash.fail))
})
failed.sources <- subset(source.hash.check,hash.fail)
failed.sources$file <- failed.sources$source.file
failed.sources$path <- failed.sources$source.path
#Check target hashes are current
target.hash.check <- ddply(trees,c("source.file","source.file.path","target.path","target.file"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$target.path[1],x$target.file[1]),serialize=FALSE)
})
x$hash.fail <- current.hash != x$target.hash
return(x)
})
failed.targets <- subset(target.hash.check,hash.fail)
sources.of.failed.targets <- subset(failed.targets,select=c("source.file","source.path"))
sources.of.failed.targets$file <- sources.of.failed.targets$source.file
sources.of.failed.targets$path <- sources.of.failed.targets$source.path
all.sources.torun <- rbind(subset(sources.of.failed.targets,select=c("file","path")),subset(failed.sources,select=c("file","path")))
all.sources.torun <- unique(all.sources.torun)
failed.targets$file <- failed.targets$target.file
failed.targets$path <- failed.targets$target.path
all.failures <- rbind(subset(sources.of.failed.targets,select=c("file","path")),subset(failed.sources,select=c("file","path")))
out.list <- list(hash.fail= all.sources.torun,stale.hash=unique(all.failures))
return(out.list)
}
project.id
source_info
source_info$project.id
Check.file.hash.source(source_info$dependency.dir)
dependency.dir <- source_info$dependency.dir
if(is.null(dependency.object)){
trees <- Harvest.trees(dependency.dir)
trees <- subset(trees,!is.na(dependency))
}else{trees <- dependency.object}
source.df <- subset(trees,!duplicated(source.hash))
#Check source hashes are current
source.hash.check <- ddply(source.df,c("source.file","source.file.path"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$source.file.path[1],x$source.file[1]),serialize=FALSE)
})
hash.fail <- current.hash != x$source.hash
return(data.frame(hash.fail))
})
source.hash.check
failed.sources <- subset(source.hash.check,hash.fail)
failed.sources$file <- failed.sources$source.file
failed.sources$path <- failed.sources$source.path
#Che
failed.sources
failed.sources <- subset(source.hash.check,hash.fail)
failed.sources$file <- failed.sources$source.file
failed.sources$path <- failed.sources$source.file.path
failed.sources
target.hash.check <- ddply(trees,c("source.file","source.file.path","target.path","target.file"),function(x){
current.hash <- ""
try({
current.hash <- Digest(file=file.path(x$target.path[1],x$target.file[1]),serialize=FALSE)
})
x$hash.fail <- current.hash != x$target.hash
return(x)
})
failed.targets <- subset(target.hash.check,hash.fail)
sources.of.failed.targets <- subset(failed.targets,select=c("source.file","source.file.path"))
sources.of.failed.targets
sources.of.failed.targets$file <- sources.of.failed.targets$source.file
sources.of.failed.targets$path <- sources.of.failed.targets$source.path
all.sources.torun <- rbind(subset(sources.of.failed.targets,select=c("file","path")),subset(failed.sources,select=c("file","path")))
all.sources.torun <- unique(all.sources.torun)
failed.targets$file <- failed.targets$target.file
failed.targets$path <- failed.targets$target.path
all.failures <- rbind(subset(sources.of.failed.targets,select=c("file","path")),subset(failed.sources,select=c("file","path")))
sources.of.failed.targets$file <- sources.of.failed.targets$source.file
sources.of.failed.targets$path <- sources.of.failed.targets$source.file.path
all.sources.torun <- rbind(subset(sources.of.failed.targets,select=c("file","path")),subset(failed.sources,select=c("file","path")))
all.sources.torun <- unique(all.sources.torun)
failed.targets$file <- failed.targets$target.file
failed.targets$path <- failed.targets$target.path
all.failures <- rbind(subset(sources.of.failed.targets,select=c("file","path")),subset(failed.sources,select=c("file","path")))
all.failures
all.sources.torun
shinyTree()
rm(source_info)
shinyTree()
shiny::runApp('~/Documents/Projects/adapr/inst/shinyApp')
shiny::runApp('~/Documents/Projects/adapr/inst/shinyApp')
load_all()
load_all()
library(devtools)
load_all()
ls()
library(adapr)
load_all()
library(adapr)
load_all()
library(adapr)
load_all()
library(adapr)
shiny::runApp('inst/shinyApp')
load_all()
library(adapr)
load_all()
library(adapr)
load_all()
library(adapr)
topdirs <- list.files(path.expand.2("~"),full.names=TRUE)
library(adapr)
topdirs <- list.files(path.expand.2("~"),full.names=TRUE)
topdirs
shiny::runApp('inst/shinyApp')
---
shinyTree()
library(adapr)
shinyTree()
get_filelist
shiny::runApp('inst/shinyApp')
load_all()
library(adapr)
load_all()
library(adapr)
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
laod_all()
load_all()
library(adapr)
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
get_publication_file("testadapr")
get_publication_file(project.id){
# Retrieves or creates publication table from project.id
source_info <- pull_source_info(project.id)
publication.file <- file.path(source_info$project.path,project.directory.tree$support,"files_to_publish.csv")
if(file.exists(publication.file)){
publication.table <- read.csv(publication.file,as.is=TRUE)
}else{
publication.table <- data.frame(Path="",Description="")[-1,]
write.csv(publication.table,publication.file,row.names=FALSE)
}
return(publication.table)
}
get_publication_file <- function(project.id){
# Retrieves or creates publication table from project.id
source_info <- pull_source_info(project.id)
publication.file <- file.path(source_info$project.path,project.directory.tree$support,"files_to_publish.csv")
if(file.exists(publication.file)){
publication.table <- read.csv(publication.file,as.is=TRUE)
}else{
publication.table <- data.frame(Path="",Description="")[-1,]
write.csv(publication.table,publication.file,row.names=FALSE)
}
return(publication.table)
}
get_publication_file("testadapr")
get_publication_file("test_adapr")
get_publication_file("adaprHome")
get_filelist("test_adapr")
get_publication_file("testadapr")
get_publication_file("test_adapr")
get_filelist <- function(project.id){
# Get files and descriptions for project
si <- pull_source_info(project.id)
files <- get.project.info.si(si)$all.files
paths <- gsub(paste0(si$project.path,"/"),"",fixed=TRUE,files$fullname)
descriptions <- files$description
results$path <-  gsub(paste0(si$project.path,"/"),"",fixed=TRUE,results$path)
return(results)
}
get.project.info.si(pull_source_info("test_adapr"))$all.files
project.id <- "test_adapr"
si <- pull_source_info(project.id)
files <- get.project.info.si(si)$all.files
files$Path <- gsub(paste0(si$project.path,"/"),"",fixed=TRUE,files$fullname)
files$Description <- files$description
results <- subset(files,select=c("Path","Description"))
return(results)
results
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
filetosend <- "Results/read_data.R/read_data.html"
input <- list(project.id = "test_adapr")
source_info <- pull_source_info(input$project.id)
publication.table <- get_publication_table(input$project.id)
outtable <- publication.table
print("Publication table retrieved")
publication.table
possible.paths <- get_filelist(input$project.id)
if(!(filetosend %in% publication.table$Path)){
print("File not in publication path")
(!(filetosend %in% publication.table$Path)
)
file.exists(file.path(source_info$project.path,filetosend))
print(paste("Sending file",filetosend))
print(filetosend)
publication.table <- rbind(publication.table,subset(possible.paths,Path==filetosend))
print(publication.table)
write.csv(publication.table,publication.file,row.names=FALSE)
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
get.project.publish.path("test_adapr")
load_all()
library(adapr)
shiny::runApp('inst/shinyApp')
load_all()
library(adapr)
library(devtools)
load_all()
library(adapr)
load_all()
library(devtools)
load_all()
library(adapr)
source('~/Documents/Projects/adapr/R/create_program_graph.R')
source('~/Documents/Projects/adapr/R/create_program_graph.R')
load_all()
library(adapr)
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
?plotOutput
source('~/Documents/Projects/adapr/R/create_program_graph.R')
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
source('~/Documents/Projects/adapr/R/create_program_graph.R')
shiny::runApp('inst/shinyApp')
temp <- create_program_graph("test_adapr")
temp$ggplot
test_adapr
project.id <- test_adapr
project.id <- "test_adapr"
#
require(ggplot2)
si <- pull_source_info(project.id)
projinfo <- get.project.info.si(si)
projgraph <- projinfo$graph
sources <- unique(projinfo$tree$source.file)
vertexnames <- subset(projinfo$all.files,file %in%sources)$fullname.abbr
lo <- layout.sugiyama(projgraph)
tp <- function(x){
x <- x[,2:1]
x[,1] <- max(x[,1])- x[,1]
return(x)
}
vertex <- vertexnames[2]
vertexTo <- vertexnames[4]
longgraph <- NULL
for(vertex in vertexnames){
shortgraph <- data.frame(from=vertex,to=vertex)
tos <- c()
for(vertexTo in vertexnames){
shortguy <- shortest_paths(projgraph,vertex,vertexTo)
if(length(shortguy$vpath[[1]])==3){
tos <- c(vertexTo,tos)
}# if one step path
}# loop over targets
if(length(tos)>0){
shortgraph <- rbind(shortgraph,data.frame(from=vertex,to=tos))
}# if any targets connected
longgraph <- rbind(longgraph,shortgraph)
}
isg <- simplify(graph.data.frame(longgraph))
#plot(isg)
#plot(isg,layout=tp(layout.sugiyama(isg)$layout))
isgdf <- igraph::as_data_frame(isg)
dfo <- tp(layout.sugiyama(isg)$layout)
colnames(dfo) <- c("x","y")
dfo <- data.frame(dfo,v=V(isg)$name)
todfo <- dfo
names(todfo)[1:2] <- c("x2","y2")
tos <- merge(isgdf,todfo,by.x="to",by.y="v")
froms <- merge(tos,dfo,by.x="from",by.y="v")
ranger <- range(c(froms$x,froms$x2))
span <- 0.1*abs(diff(ranger))
horizontal.range <- c(ranger[1]-span,ranger[2]+span)
rangery <- range(c(froms$y,froms$y2))
graph.height <- length(unique(c(froms$y,froms$y2)))
graph.width <- length(unique(c(froms$y,froms$y2)))
dotsize0 <- if(graph.height>5){dot.size <-1+10/graph.height}else{dot.size0 <- 10}
text.nudge0 <- 0.05*abs(diff(rangery))
text.nudge0 <- if(graph.height>5){text.nudge0 <-text.nudge0/graph.height}
text.size0 <- 1
text.size0 <- if(graph.width>5){text.size0 <-2 + 2*text.size0/graph.width}
proj.gg <- ggplot(dfo,aes(x=x,y=y,label=basename(as.character(v))))+geom_text(nudge_y=text.nudge0,size=text.size0,color="red")+geom_point(size=dotsize0,color="skyblue",alpha=0.5)+annotate(geom="segment",x=froms$x,y=froms$y,xend=froms$x2,yend=froms$y2,arrow=arrow(length=unit(0.2,"cm"),type="closed"),alpha=0.5/ifelse(graph.width>5,5,1))+scale_x_continuous(limits=horizontal.range)+theme(axis.line=element_blank(),axis.text.x=element_blank(),
axis.text.y=element_blank(),axis.ticks=element_blank(),
axis.title.x=element_blank(),
axis.title.y=element_blank(),legend.position="none",
panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),plot.background=element_blank())+ggtitle(paste(project.id,"R Script Graph"))
proj.gg
proj.gg <- ggplot(dfo,aes(x=x,y=y,label=basename(as.character(v))))+geom_text(nudge_y=text.nudge0,size=text.size0,color="red")
proj.gg
text.size0
text.size0 <- 1
text.size0 <- if(graph.width>5){text.size0 <-2 + 2*text.size0/graph.width}
text.size0
text.size0 <- 1
graph.width
graph.height <- length(unique(c(froms$y,froms$y2)))
graph.width <- length(unique(c(froms$y,froms$y2)))
text.size0 <-2 + 2*text.size0/graph.width
source('~/Documents/Projects/adapr/R/create_program_graph.R')
shiny::runApp('inst/shinyApp')
source('~/Documents/Projects/adapr/R/create_program_graph.R')
shiny::runApp('inst/shinyApp')
shiny::runApp('inst/shinyApp')
